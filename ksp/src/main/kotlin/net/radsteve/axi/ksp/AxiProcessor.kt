package net.radsteve.axi.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import java.io.OutputStreamWriter
import java.nio.charset.StandardCharsets

public class AxiProcessor(
  env: SymbolProcessorEnvironment,
) : SymbolProcessor {
  private companion object Identifier {
    const val AUTO_REGISTERED_ANNOTATION: String = "net.radsteve.axi.command.AutoRegistered"
    const val AUTO_GENERATED_PACKAGE: String = "_axi_ksp_autogenerated"
    const val COMMAND: String = "net.radsteve.axi.command.Command"
  }

  private val gen: CodeGenerator = env.codeGenerator

  private fun createCodeFile(
    pkg: String,
    name: String,
    content: String,
    vararg deps: KSFile,
  ) = runCatching {
    gen.createNewFile(
      Dependencies(false, *deps),
      pkg,
      name,
    ).use { out ->
      OutputStreamWriter(out, StandardCharsets.UTF_8).use { writer ->
        writer.write(content)
      }
    }
  }

  private fun createFile(
    path: String,
    ext: String,
    content: String,
  ) = runCatching {
    gen.createNewFileByPath(
      Dependencies(false),
      path,
      ext,
    ).use { out ->
      OutputStreamWriter(out, StandardCharsets.UTF_8).use { writer ->
        writer.write(content)
      }
    }
  }

  private fun createLoader() {
    createFile(
      "net/radstevee/axi/plugin/loader/AxiPluginLoader",
      "java",
      PluginLoader.CONTENT,
    )
  }

  private fun createCommandServices(services: Iterable<String>) {
    createFile(
      "META-INF/services/$COMMAND",
      "",
      services.joinToString(separator = "\n"),
    )
  }

  private fun processCommands(resolver: Resolver) {
    val properties = resolver.getSymbolsWithAnnotation(AUTO_REGISTERED_ANNOTATION)
      .filterIsInstance<KSPropertyDeclaration>()
    val services = mutableListOf<String>()

    properties.forEach { property ->
      val declQualified = property.qualifiedName!!.asString()
      val declName = property.simpleName.asString()
      val newPackage = property.packageName.asString() + ".$AUTO_GENERATED_PACKAGE"
      val newClassName = "__autogenerated_$declName"
      val code = """
                // spotless:off
                //CHECKSTYLE:OFF
                @file:Suppress("ktlint")
                package $newPackage
                
                @Deprecated("auto generated class", level = DeprecationLevel.HIDDEN)
                @Suppress("ClassName")
                public class $newClassName : $COMMAND by $declQualified
      """.trimIndent()

      services.add("$newPackage.$newClassName")

      createCodeFile(newPackage, newClassName, code, property.containingFile!!)
    }

    if (services.isEmpty()) {
      return
    }

    createCommandServices(services)
  }

  override fun process(resolver: Resolver): List<KSAnnotated> {
    processCommands(resolver)
    createLoader()
    return emptyList()
  }
}
